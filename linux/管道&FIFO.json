[
  {
    "title": "画布 1",
    "topic": {
      "title": "管道&FIFO",
      "topics": [
        {
          "title": "管道是什么",
          "topics": [
            {
              "title": "两个进程间进行单向通信的机制, 是半双工,如果要实现全双工,需要两个管道"
            },
            {
              "title": "管道只能用于父子进程或者兄弟进程间通信。，也就是说管道只能用于具有亲缘关系的进程间通信"
            },
            {
              "title": "管道中的数据时字节流,(不是字符流),也就是说管道中的数据不存在 消息的概念, 可以从管道中读取任意大小块的数据. 通过管道的数据都是顺序的,即先进先出."
            },
            {
              "title": "管道无法随机的访问数据."
            },
            {
              "title": "可控制阻塞式的读取或写入数据,可以用于进程间同步."
            },
            {
              "title": "管道机制:可以保证PIPE_BUF字节以下大小的字节 写入 是原子的. 保证写入端在写入一个基本块的时候不存在乱序. 但是多个写入端 并发写入还是需要 进行同步,或者根据具体的协议 进行处理.(否则读取端 不知道如何解释读取的数据.)"
            },
            {
              "title": "管道是一个缓冲.,有容量的,通过缓冲可以减少传输的次数, 越大的缓冲提供的弹性越大, 即读写速率不同导致 读阻塞或者写阻塞的问题."
            }
          ]
        },
        {
          "title": "为什么要有管道",
          "topics": [
            {
              "title": "想象一下如果没有管道, 如何实现两个进程之间的数据流共享呢? 所谓数据流是指 一方写入,一方读取.明显的依赖于信号机制 无法传输大量数据, 依赖于mmap, 只是共享一个数组, 如何控制读取和写入呢? 客户端使用会极为复杂."
            },
            {
              "title": "有了管道 则是方便的对读取写入进行控制, 提供流式的读取写入.当空或者满时,提供阻塞接口,进行进程同步."
            }
          ]
        },
        {
          "title": "淘气三千问",
          "topics": [
            {
              "title": "如果读取时, 写一端已经关闭, 会怎样",
              "topics": [
                {
                  "title": "直接返回0 EOF "
                }
              ]
            },
            {
              "title": "如何区分非阻塞情况下, 管道数据为空, 和对方已经关闭这两个场景. 返回 EAGAIN 错误码和EOF区分开, 否则返回read读取的字节数"
            },
            {
              "title": "如何处理管道read已经关闭的情况下,  write 问题",
              "topics": [
                {
                  "title": "broken pipe, 同时内核会给进程发送sigpipe信号"
                }
              ]
            }
          ]
        },
        {
          "title": "如何使用管道",
          "topics": [
            {
              "title": "pipe(int filedes[2]) 传递两个fd, 返回实际的读写文件符",
              "topics": [
                {
                  "title": "read, write 可对fd系统调用"
                },
                {
                  "title": "也可以使用c函数库 stdio . 但是需要先用fdopen 获取文件描述符相关的文件流."
                },
                {
                  "title": "这样在文件流的部分也出现了一层缓冲, 需要调用fflush"
                }
              ]
            },
            {
              "title": "如何多进程共享",
              "topics": [
                {
                  "title": "在单进程内使用管道意义不大."
                },
                {
                  "title": "管道只能在有亲属关系的进程间进行通信,即通过fork创建子进程,子进程共享父进程的文件描述符等数据."
                }
              ]
            },
            {
              "title": "如何关闭管道",
              "topics": [
                {
                  "title": "为什么需要关闭管道,当管道所有的写入文件描述符都关闭后, 则不可能有任何写入. 如果读取到末尾, 则会抛出EOF ,否则一直阻塞(认为还会存在写入的可能)"
                },
                {
                  "title": "如果读取描述符不关闭, 则写入满了,认为还会存在读取数据的可能. 所以也会被阻塞."
                },
                {
                  "title": "只有当正确的关闭文件描述符, 才能保证相关数据的读取写入 不会被死锁,即认为还能读取, 其实根本不会再写入了. 再设计程序时需要特别注意"
                }
              ]
            },
            {
              "title": "用于进程同步",
              "topics": [
                {
                  "title": "当使用读写时, 第一次对管道的读或者写都会被阻塞. 只有对方写入或读取, 才会让双方同时解除阻塞, 可以将管道作为进程同步的一种机制.即双方同时满足一个状态."
                }
              ]
            },
            {
              "title": "popen",
              "topics": [
                {
                  "title": "FILE *popen(const char * cmd, const char * mode)
int pclose(FILE * stream)"
                },
                {
                  "title": "可以使用popen, 创建一个管道,通过这个管道 可以 获取 子命令的输出,或者作为其输入."
                },
                {
                  "title": "由于popen 返回FILE, 在stdio 库使用FILE时,会有块缓冲,为 保证在给子进程传递数据时足够及时, 需要在FILE 上及时的使用fflush刷新数据,(pclose时也会刷新)"
                }
              ]
            }
          ]
        },
        {
          "title": "如何分割字节流",
          "topics": [
            {
              "title": "使用特殊的分隔符进行分割, 例如换行"\n" 如果传输\n 需要对\进行转义 例如\\解释为\"
            },
            {
              "title": "按照特殊的协议,例如带请求头的协议.,使用请求头标记 请求body的数据流大小. 一但出现错误, 关闭管道."
            },
            {
              "title": "要保证写入的数据尽量小于4k, 大于4k无法保证写入的原子, 多个写入端可能存在乱序的情况, 此种场景需要额外的进程同步,例如锁"
            }
          ]
        },
        {
          "title": "非阻塞的调用",
          "topics": [
            {
              "title": "可以在open 打开管道和FIFO时,可以指定非阻塞模式.",
              "topics": [
                {
                  "title": "使用read 调用管道 fd时, 可以使用fcntl 控制fd的flag 为非阻塞."
                },
                {
                  "title": "open("fifo path name", flags) 可以指定非阻塞"
                },
                {
                  "title": "写入管道时,如果指定非阻塞, 但是没有对应读取端, 则会报错"
                },
                {
                  "title": "非阻塞模式的作用",
                  "topics": [
                    {
                      "title": "保证单进程读取写入一个管道 可以成功(不会因为阻塞而死锁)"
                    },
                    {
                      "title": "可以避免死锁问题"
                    }
                  ]
                }
              ]
            },
            {
              "title": "阻塞非阻塞的比较",
              "topics": [
                {
                  "title": "当非阻塞时, 写入端打开时, 但是管道是空的. 此时读取会报错(EAGAIN)
如果是阻塞模式, 则读取会阻塞",
                  "topics": [
                    {
                      "title": "写入端如果关闭, 管道为空, 则会返回EOF标识读取到了末尾"
                    }
                  ]
                },
                {
                  "title": "当写入FIFO时, 非阻塞模式下, 当写入字节小于PIPE_BUF时. 如果能完全写入, 则原子写入, 否则返回EAGIN 
在阻塞模式下, 会保证每次写入都完全写入才会被返回. 如果大于PIPE_BUF,原子保证小于PIPE_BUF部分,其他部分会阻塞,直到满足(或者被信号唤醒)",
                  "topics": [
                    {
                      "title": "管道保证小于PIPE_BUF字节的数据原子性"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "title": "管道和FIFO 的区别和联系",
          "topics": [
            {
              "title": "FIFO 和 管道 的使用方式基本类似, read, write等规则也是相同的,只是 FIFO 是命名的,可以看做是文件系统上的一个文件, 满足文件权限的都可以访问., 这样就避免了管道的亲属进程通信限制"
            }
          ]
        },
        {
          "title": "FIFO ",
          "topics": [
            {
              "title": "mkfile(char * pathname, mode)",
              "topics": [
                {
                  "title": "mode指定FIFO 的文件权限"
                }
              ]
            }
          ]
        }
      ]
    },
    "structure": "org.xmind.ui.map.unbalanced"
  }
]