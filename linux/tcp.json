[
  {
    "title": "画布 1",
    "topic": {
      "title": "tcp",
      "topics": [
        {
          "title": "淘气三千问",
          "topics": [
            {
              "title": "tcp重发时,如果一直失败会怎样",
              "topics": [
                {
                  "title": "会reset这个请求",
                  "topics": [
                    {
                      "title": "net.ipv4.tcp_retries2",
                      "topics": [
                        {
                          "title": "最大的重发次数."
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "title": "如何理解tcp , udp 有状态和无状态.",
              "topics": [
                {
                  "title": "tcp 中三次握手, 四次挥手分别在客户端和服务端记录本次tcp 连接的状态信息, 同时报文中也存在基于状态变更的报文内容. 以及tcp 处理可靠性时, 串行发送, 基于package 序列进行超时重传,ack,滑动窗口等特性,都是基于状态的. 没收到一个报文都需要检测该报文 是不是符合当前状态. 否则丢弃"
                }
              ]
            }
          ]
        },
        {
          "title": "Time_wait时间",
          "topics": [
            {
              "title": "为什么最后客户端还要等待 2*MSL的时间呢?

MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。

第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。"
            },
            {
              "title": "旧链接等待2MSL,时间就会将所有的请求等待超时,如果接收到任何报文也不会回复,响应.避免对端误会..
这样新的链接建立后,就不会出现任何 旧的报文回复"
            },
            {
              "title": "可以配置 timewait时间,立即释放链接"
            },
            {
              "title": "主动释放一段最先关闭链接"
            }
          ]
        },
        {
          "title": "为什么建立连接是三次握手，关闭连接确是四次挥手呢？",
          "topics": [
            {
              "title": "建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。"
            }
          ]
        },
        {
          "title": "tcp",
          "topics": [
            {
              "title": "[Image]"
            },
            {
              "title": "[Image]"
            },
            {
              "title": "[Image]"
            }
          ]
        },
        {
          "title": "缓冲区",
          "topics": [
            {
              "title": "创建一个TCP的socket, 同时在内核中创建一个 发送缓冲区 和一个 接收缓冲区; 
调用write时, 数据会先写入发送缓冲区中; 
如果发送的字节数太大, 会被拆分成多个TCP的数据包发出; 
如果发送的字节数太小, 就会先在缓冲区里等待, 等到缓冲区大小差不多了, 或者到了其他合适的时机再发送出去; 
接收数据的时候, 数据也是从网卡驱动程序到达内核的接收缓冲区; 
然后应用程序可以调用read从接收缓冲区拿数据; 
另一方面, TCP的一个连接, 既有发送缓冲区, 也有接收缓冲区, 
那么对于这一个连接, 既可以读数据, 也可以写数据, 这个概念叫做 全双工"
            },
            {
              "title": "如果读缓冲区满了. 此时报文就会被丢弃掉. 对端会重发.说明接收端处理比较慢,此时 TCP 滑动窗口会变少"
            },
            {
              "title": "读缓冲区不存在溢出的问题.即按照FIFO等将已经ack的数据丢失, 而是将新收到的数据丢失, 同时减少滑动窗口, 对端发现超时后,会重发",
              "makers": [
                "priority-1",
                "task-done",
                "flag-red"
              ]
            },
            {
              "title": "网卡环形缓冲区存在FIFO溢出问题.",
              "makers": [
                "task-done",
                "flag-red",
                "priority-1"
              ]
            }
          ]
        },
        {
          "title": "粘包问题",
          "topics": [
            {
              "title": "首先要明确, 粘包问题中的 “包”, 是指应用层的数据包. 
在TCP的协议头中, 没有如同UDP一样的 “报文长度” 字段 
但是有一个序号字段. 
站在传输层的角度, TCP是一个一个报文传过来的. 按照序号排好序放在缓冲区中. 
站在应用层的角度, 看到的只是一串连续的字节数据. 
那么应用程序看到了这一连串的字节数据, 就不知道从哪个部分开始到哪个部分是一个完整的应用层数据包. 
此时数据之间就没有了边界, 就产生了粘包问题

那么如何避免粘包问题呢? 
归根结底就是一句话, 明确两个包之间的边界"
            },
            {
              "title": "解决",
              "topics": [
                {
                  "title": "对于定长的包 
- 保证每次都按固定大小读取即可 
例如上面的Request结构, 是固定大小的, 那么就从缓冲区从头开始按sizeof(Request)依次读取即可

对于变长的包 
- 可以在数据包的头部, 约定一个数据包总长度的字段, 从而就知道了包的结束位置 
还可以在包和包之间使用明确的分隔符来作为边界(应用层协议, 是程序员自己来定的, 只要保证分隔符不和正文冲突即可)"
                }
              ]
            },
            {
              "title": "读写缓冲区是字节数组 ->  封装为报文到对端, TCP协议栈负责这个过程."
            }
          ]
        },
        {
          "title": "TCP_NODELAY、TCP_CORK, TCP_QUICKACK",
          "topics": [
            {
              "title": "delay ack",
              "topics": [
                {
                  "title": "当协议栈接受到TCP数据时，并不一定会立刻发送ACK响应，而是倾向于等待一个超时或者满足特殊条件时再发送。对于Linux实现，这些特殊条件如下：
1）收到的数据已经超过了full frame size
2）或者处于快速回复模式
3）或者出现了乱序的包
4）或者接收窗口的数据足够多
如果接收方有数据回写，则ACK也会搭车一起发送。当以上条件都不满足时，接收方会延迟40ms再回应ACK。",
                  "makers": [
                    "task-done",
                    "priority-1",
                    "star-red"
                  ]
                }
              ]
            },
            {
              "title": "为什么TCP_NODELAY失效",
              "topics": [
                {
                  "title": "TCP_NODELAY同时禁止了nagle算法和delayed ACK算法，
因此小块数据可以直接发送。然而Linux实现中，TCP_NODELAY只禁止了nagle算法。另一方面，协议栈在发送包的时候，不仅受到TCP_NODELAY的影响，还受到协议栈里面拥塞窗口的影响。由于server端delayed ack，client迟迟无法收到ack应答，拥塞窗口堵满，从而无法继续发送更多数据；一直到40ms后ack达到，才能继续发送（题外话： TCP_NODELAY在FREEBSD上性能优于Linux上，因为FREEBSD并不像Linux一样需要第一个包到达后就响应ACK）。"
                },
                {
                  "title": "TCP_NODELAY只禁止了nagle算法"
                }
              ]
            },
            {
              "title": ". TCP_QUICKACK的作用和限制",
              "topics": [
                {
                  "title": "而TCP_QUICKACK选项就是向内核建议进入快速回复模式。快速回复ack模式的判断条件如下：(tp->ack.quick && tp->ack.pingpong)，其中设置QUICKACK选项会置pingpong=0。
然而，随着TCP连接的重用和数据的不断收发，快速回复模式有可能失效。例如在后续的交互过程当中，pingpong变为1的条件就有：1.收到fin后；2. 发送方发送数据时，发现当前时间与上次接收数据的时间小于40ms。此外，发送方发现数据包带有ack标志位时，也会减小ack.quick值。这些都会导致快速回复模式的退出。因此，即使每次接受数据前都设置TCP_QUICKACK选项，也不能完全解决delayed ack问题。"
                }
              ]
            }
          ]
        },
        {
          "title": "超时重发& 快速重发",
          "topics": [
            {
              "title": "重发",
              "topics": [
                {
                  "title": "超时重发",
                  "topics": [
                    {
                      "title": "发送方送出一个TCP片段后，将开始计时，等待该TCP片段的ACK回复。如果接收方正确接收到符合次序的片段，接收方会利用ACK片段回复发送方。发送方得到ACK回复后，继续移动窗口，发送接下来的TCP片段。如果直到计时完成，发送方还是没有收到ACK回复，那么发送方推断之前发送的TCP片段丢失，因此重新发送之前的TCP片段"
                    }
                  ]
                },
                {
                  "title": "快速重发",
                  "topics": [
                    {
                      "title": "当接收方收到乱序片段的时候，需要重复发送ACK。比如接收到乱序片段9的时候，接收方需要回复ACK。回复号为8 (7+1)。此后接收方如果继续收到乱序片段(序号不是8的片段)，将再次重复发送ACK=8。当发送方收到3个ACK=8的回复时，发送方推断片段8丢失。即使此时片段8的计时器还没有超时，发送方会打断计时，直接重新发送片段8，这就是快速重新发送机制"
                    },
                    {
                      "title": "乱序发送",
                      "topics": [
                        {
                          "title": "由于IP包的传输是无序的，所以接收方有可能先收到后发出的片段，也就是乱序(out-of-order)片段。乱序片段的序号并不等于最近发出的ACK回复号。已接收的文本流和乱序片段之间将出现空洞(hole)，也就是等待接收的空位。比如已经接收了正常片段5,6,7，此时又接收乱序片段9。这时片段8依然空缺，片段8的位置就是一个空洞"
                        }
                      ]
                    },
                    {
                      "title": "快速重新发送机制利用重复的ACK来提示空洞的存在。当重复次数达到阈值时，认为空洞对应的片段在网络中丢失。快速重新发送机制提高了检测丢失片段的效率，往往可以在超时之前探测到丢失片段，并重复发送丢失的片段。"
                    }
                  ]
                }
              ]
            },
            {
              "title": "时间如何定义",
              "topics": [
                {
                  "title": "RTT",
                  "topics": [
                    {
                      "title": "1. 发送片段从发送方到接收方的传输，2. ACK片段从接收方到发送方的传输。整个过程实际耗费的时间称做往返时间(RTT, round trip time)"
                    }
                  ]
                },
                {
                  "title": "RTO",
                  "topics": [
                    {
                      "title": "计时等待的时间叫做重新发送超时时间(RTO, retransmission timeout)。"
                    }
                  ]
                },
                {
                  "title": "在RTT浮动的情况下，如果我们设置了过小的RTO，那么TCP会等待很短的时间之后重新发送，而实际上之前发送的片段并没有丢失，只是传输速度比较慢而已，这样，网络中就被重复注入TCP片段，从而浪费网络传输资源。另一方面，如果RTO时间过长，那么当TCP片段已经实际丢失的情况下，发送方不能及时重新发送，会造成网络资源的闲置。所以，RTO必须符合当前网络的使用状况。网络状况越好，RTO应该越短；网络状况越差，RTO应该越长"
                },
                {
                  "title": "RTO统计",
                  "topics": [
                    {
                      "title": "TCP协议通过统计RTT，来决定合理的RTO。发送方可以测量每一次TCP传输的RTT (从发送出数据片段开始，到接收到ACK片段为止)，这样的每次测量得到的往返时间，叫做采样RTT(srtt, sampling round trip time)。建立连接之后，每次的srtt作为采样样本，计算平均值(mean)和标准差(standard deviation)，并让RTO等于srtt平均值加上四倍的srtt标准差。"
                    },
                    {
                      "title": "RTO = mean + 4 std"
                    },
                    {
                      "title": "RTO 为RTT统计的平均值+ 4倍的标准差"
                    }
                  ]
                }
              ]
            },
            {
              "title": "iink",
              "topics": [
                {
                  "title": "https://blog.csdn.net/nizhannizhan/article/details/47688439"
                }
              ]
            }
          ]
        },
        {
          "title": "拥塞控制(拥塞窗口也就是滑动窗口)",
          "topics": [
            {
              "title": "慢启动 机制, 先发少量的数据, 探探路, 摸清当前的网络拥堵状态以后, 再决定按照多大的速度传输数据",
              "topics": [
                {
                  "title": "慢启动不是每次发送tcp 报文小,而是滑动窗口比较小."
                }
              ]
            },
            {
              "title": "发送开始的时候, 定义拥塞窗口大小为1;
每次收到一个ACK应答, 拥塞窗口加1;
每次发送数据包的时候, 将拥塞窗口和接收端主机反馈的窗口大小做比较, 取较小的值作为实际发送的窗口"
            },
            {
              "title": "[Image]"
            },
            {
              "title": "初始慢,但是指数增长,到达阈值 增加1"
            },
            {
              "title": "当TCP开始启动的时候, 慢启动阈值等于窗口最大值
在每次超时重发的时候, 慢启动阈值会变成原来的一半, 同时拥塞窗口置回1"
            },
            {
              "title": "延迟应答",
              "topics": [
                {
                  "title": "如果接收数据的主机立刻返回ACK应答, 这时候返回的窗口可能比较小. 
假设接收端缓冲区为1M. 一次收到了500K的数据; 
如果立刻应答, 返回的窗口大小就是500K; 
但实际上可能处理端处理的速度很快, 10ms之内就把500K数据从缓冲区消费掉了; 在这种情况下, 接收端处理还远没有达到自己的极限, 即使窗口再放大一些, 也能处理过来; 
如果接收端稍微等一会儿再应答, 比如等待200ms再应答, 那么这个时候返回的窗口大小就是1M

窗口越大, 网络吞吐量就越大, 传输效率就越高. 
TCP的目标是在保证网络不拥堵的情况下尽量提高传输效率"
                },
                {
                  "title": "何时延迟应答",
                  "topics": [
                    {
                      "title": "数量限制: 每隔N个包就应答一次"
                    },
                    {
                      "title": "时间限制: 超过最大延迟时间就应答一次"
                    }
                  ]
                }
              ]
            },
            {
              "title": "阿里云 高精度拥塞控制)",
              "topics": [
                {
                  "title": "之前拥塞控制协议",
                  "topics": [
                    {
                      "title": "要依赖于端的信息（例如丢包信息，延迟信息），以及极为有限的设备反馈信息（如 1 个比特的 ECN）做拥塞控制"
                    },
                    {
                      "title": "通过在端上调节流量，以维持网络最佳平衡状态。发送方根据网络承载情况控制发送速率，以获取高性能并避免拥塞崩溃（congestion collapse）导致网络性能下降几个数量级，并在多个数据流之间产生近似最大化最小流的公平分配。发送方与接收方确认包、包丢失以及定时器情况，估计网络拥塞状态，从而调节数据流的发送速率，这被称为网络拥塞控制"
                    },
                    {
                      "title": "主要依赖于端上的信息, 通过ack, 超时重发调整窗口阈值"
                    }
                  ]
                },
                {
                  "title": " HPCC 则创新性地运用了最新网络设备提供的细粒度负载信息而全新设计了拥塞控制算法"
                },
                {
                  "title": "利用精确链路负载信息直接计算合适的发送速率，而不是像现有的 TCP 和 RDMA 拥塞控制算法那样迭代探索合适的速率；HPCC 速率更新由数据包的 ACK 驱动，而不是像 DCQCN 那样靠定时器驱动。"
                }
              ]
            }
          ]
        },
        {
          "title": "流量控制",
          "topics": [
            {
              "title": "接收端处理数据的速度是有限的. 如果发送端发的太快, 导致接收端的缓冲区被填满, 这个时候如果发送端继续发送, 就会造成丢包, 进而引起丢包重传等一系列连锁反应. 
因此TCP支持根据接收端的处理能力, 来决定发送端的发送速度. "
            },
            {
              "title": "接收端可以控制滑动窗口大小"
            },
            {
              "title": "接收端将自己可以接收的缓冲区大小放入 TCP 首部中的 “窗口大小” 字段, 
通过ACK通知发送端; 
窗口大小越大, 说明网络的吞吐量越高; 
接收端一旦发现自己的缓冲区快满了, 就会将窗口大小设置成一个更小的值通知给发送端; 
发送端接受到这个窗口大小的通知之后, 就会减慢自己的发送速度; "
            },
            {
              "title": "如果接收端缓冲区满了, 就会将窗口置为0; 
这时发送方不再发送数据, 但是需要定期发送一个窗口探测数据段, 让接收端把窗口大小再告诉发送端.",
              "makers": [
                "priority-1"
              ]
            }
          ]
        },
        {
          "title": "滑动窗口",
          "topics": [
            {
              "title": "窗口大小指的是无需等待确认应答就可以继续发送数据的最大值. 
上图的窗口大小就是4000个字节 (四个段).

发送前四个段的时候, 不需要等待任何ACK, 直接发送 
收到第一个ACK确认应答后, 窗口向后移动, 继续发送第五六七八段的数据…

因为这个窗口不断向后滑动, 所以叫做滑动窗口. 
操作系统内核为了维护这个滑动窗口, 需要开辟发送缓冲区来记录当前还有哪些数据没有应答 
只有ACK确认应答过的数据, 才能从缓冲区删掉. "
            },
            {
              "title": "避免无限制的往对端发送数据包,是发送方需要注意的"
            },
            {
              "title": "[Image]"
            },
            {
              "title": "如果发送端主机连续三次收到了同样一个 “1001” 这样的应答, 就会将对应的数据 1001 - 2000 重新发送 "
            },
            {
              "title": "发送方收到接收到窗口反馈大小 之后会移动滑动窗口. 当接收端满了, 此时可以通过两种机制 客户端主动探测窗口大小, 或接收端主动推送大小变更"
            }
          ]
        },
        {
          "title": "探活",
          "topics": [
            {
              "title": "TCP设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。"
            },
            {
              "title": "应用层会使用 read connect timeout 等,防止对端 hang 住,或者挂掉"
            }
          ]
        },
        {
          "title": "超时重传",
          "topics": [
            {
              "title": "主机A发送数据给B之后, 可能因为网络拥堵等原因, 数据无法到达主机B "
            },
            {
              "title": "如果主机A在一个特定时间间隔内没有收到B发来的确认应答, 就会进行重发 "
            },
            {
              "title": "但是主机A没收到确认应答也可能是ACK丢失了. "
            },
            {
              "title": "时间计算",
              "topics": [
                {
                  "title": " 超时以500ms为一个单位进行控制, 每次判定超时重发的超时时间都是500ms的整数倍. 
如果重发一次之后, 仍然得不到应答, 等待 2*500ms 后再进行重传. 如果仍然得不到应答, 等待 4*500ms 进行重传. 
依次类推, 以指数形式递增. 累计到一定的重传次数, TCP认为网络异常或者对端主机出现异常, 强制关闭连接."
                }
              ]
            },
            {
              "title": "确认时,只需要确认最大序号即可,当丢掉低报文,时,会发送低报文+1 的响应.如果发送方接受三次这样的 ack,就会重发."
            },
            {
              "title": "一个是超时,一个是三次低报文 ack确认"
            },
            {
              "title": "超时时间并不是固定不变的. 局域网和公网 报文ack 时间是不同的, 网络拥塞状况不通时间也是不同的.所以需要根据历史的ack 时间进行动态调整,而不是长期使用一个固定值"
            }
          ]
        },
        {
          "title": "因为既要保证可靠性, 同时又要尽可能提高性能."
        },
        {
          "title": "os socket读写",
          "makers": [
            "priority-2"
          ],
          "topics": [
            {
              "title": "写到write buffer中即可,满了就阻塞",
              "topics": [
                {
                  "title": "nio是尽力写,写多少是多少,通过返回值控制.如果写入失败,客户端自己缓存重试"
                }
              ]
            },
            {
              "title": "读也从 read buffer,空了就阻塞",
              "topics": [
                {
                  "title": "nio读,有多少读多少"
                }
              ]
            },
            {
              "title": "写缓冲在收到对端的 ack 之后,就会移除对应的报文",
              "topics": [
                {
                  "title": null
                }
              ]
            },
            {
              "title": "fflush对应清空缓存区的作用,该接口时阻塞的,或者说是很慢的."
            },
            {
              "title": "读缓冲满了,自然会调整窗口大小"
            }
          ]
        },
        {
          "title": "网络异常问题",
          "topics": [
            {
              "title": "对一个sync包 reset",
              "topics": [
                {
                  "title": "请求建联的服务端并没有监听这个端口。"
                },
                {
                  "title": "一些原因导致服务端无法在这个端口建联成功，如资源被耗尽，从而无法建立起新的连接。"
                },
                {
                  "title": "出于安全考虑,可能并不会 reset,直接丢弃该报文(timeout)"
                },
                {
                  "title": "connection refused"
                }
              ]
            },
            {
              "title": "refused",
              "topics": [
                {
                  "title": "指定ip地址的机器不能找到(也就是说从当前机器不存在到指定ip路由)，"
                },
                {
                  "title": "或者是该ip存在，但找不到指定的端口进行监听"
                }
              ]
            },
            {
              "title": ":Socket is closed",
              "topics": [
                {
                  "title": "该异常在客户端和服务器端均可能发生。异常的原因是己方主动关闭了连接后,
(调用了Socket的close方法)再对网络连接进行读写操作。"
                }
              ]
            },
            {
              "title": "Connection reset
Connect reset by peer:Socket write error",
              "topics": [
                {
                  "title": " 该异常在客户端和服务器端均有可能发生，引起该异常的原因有两个，
第一个就是假如一端的Socket被关闭（或主动关闭或者因为异常退出而引起的关闭）， 另一端仍发送数据，发送的第一个数据包引发该异常(Connect reset by peer)。

另一个是一端退出，但退出时并未关闭该连接，另一端假如在从连接中读数据则抛出该异常（Connection reset）。简单的说就是在连接断开后的读和写操作引起的"
                },
                {
                  "title": "服务端出现时",
                  "topics": [
                    {
                      "title": "a) 服务器的并发连接数超过了其承载量，服务器会将其中一些连接主动Down掉."
                    },
                    {
                      "title": "b) 在数据传输的过程中，浏览器或者接收客户端关闭了，而服务端还在向客户端发送数据。"
                    }
                  ]
                },
                {
                  "title": "客户端发现对端 reset,说明服务端处理失败,不得已 reset了链接,和超时不同,超时说明客户端不愿意再等了,此时服务端还不知道呢? 而 reset是服务端知道自己无法处理了,所以主动 reset了链接"
                },
                {
                  "title": "使用tcpdump 可以抓包.看到服务端首先发送了 reset关闭了链接. timeout 是客户端首先关闭链接"
                }
              ]
            },
            {
              "title": "Broken pipe",
              "topics": [
                {
                  "title": "在抛出SocketExcepton:Connect reset by peer:Socket write error后，假如再继续写数据则抛出该异常。前两个异常的解决方法是首先确保程序退出前关闭所有的网络连接，其次是要检测对方的关闭连接操作，发现对方 关闭连接后自己也要关闭该连接"
                }
              ]
            }
          ]
        }
      ]
    },
    "structure": "org.xmind.ui.map.unbalanced"
  }
]