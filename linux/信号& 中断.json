[
  {
    "title": "画布 1",
    "topic": {
      "title": "信号& 中断",
      "topics": [
        {
          "title": "信号",
          "topics": [
            {
              "title": "种类",
              "topics": [
                {
                  "title": "实时可靠",
                  "topics": [
                    {
                      "title": "大于32的信号"
                    },
                    {
                      "title": "不会丢失"
                    },
                    {
                      "title": "会排队处理"
                    }
                  ]
                },
                {
                  "title": "非实时,不可靠",
                  "topics": [
                    {
                      "title": "kill ,Ctrl C等 小于32的信号"
                    },
                    {
                      "title": "可能丢失"
                    },
                    {
                      "title": "不会排队处理"
                    }
                  ]
                }
              ]
            },
            {
              "title": "系统调用",
              "topics": [
                {
                  "title": "singal 基本版本"
                },
                {
                  "title": "sigaction",
                  "topics": [
                    {
                      "title": "可添加发送内容"
                    }
                  ]
                },
                {
                  "title": "pause",
                  "topics": [
                    {
                      "title": "将进程挂起等待信号"
                    }
                  ]
                },
                {
                  "title": "sigqueue",
                  "topics": [
                    {
                      "title": "带参数的信号发送"
                    }
                  ]
                }
              ]
            },
            {
              "title": "具体步骤(软中断)",
              "topics": [
                {
                  "title": "在每个进程之中，都有存着一个表，里面存着每种信号所代表的含义，而这也是信号机制的根本。由于信号的触发和发送是随机的，也就是异步的。

接收进程是无法预知什么时间，会收到哪个信号的。下面就开始讲下信号的详细发送机制，举例说明，如果有A，B两个进程，A进程接收到出发条件，开始发送信号给B进程，信号并不是直接从进程A发送给进程B，而是要通过内核来进行转发。之所以要通过内核来转发，这样做的目的应该也是为了对进程的管理和安全因素考虑。因为在这些信号当中，SIGSTOP和SIGKILL这两个信号是可以将接收此信号的进程停掉的，而这类信号，肯定是需要有权限才可以发出的，不能够随便哪个程序都可以随便停掉别的进程。

A进程发送的信号消息，其实就是根据上面的那个信号表，根据需要对相应的表项进行设置。内核接受到这个信号消息后，会先检查A进程是否有权限对B进程的信号表对应的项进行设置，如果可以，就会对B进程的信号表进行设置，这里面信号处理有个特点，就是没有排队的机制，也就是说某个信号被设置之后，如果B进程还没有来及进行响应，那么如果后续第二个同样的信号消息过来，就会被阻塞掉，也就是丢弃。

"
                },
                {
                  "title": "1) A进程调用信号发送函数，发送信号给B，这是软中断，所以A进程会进入内核态运行操作系统的信号调度代码"
                },
                {
                  "title": "2) 操作系统发现B进程正在运行，于是写入管理B进程的某个数据结构",
                  "topics": [
                    {
                      "title": "如果是不可靠信号,那么这个信号不会被排队,会直接覆盖掉之前的信号,而之前的信号还没有被处理"
                    },
                    {
                      "title": "pending 队列"
                    }
                  ]
                },
                {
                  "title": "3) 操作系统返回给A，A继续执行"
                },
                {
                  "title": "4) B进程分配的处理器时间用完了，被时钟硬件中断"
                },
                {
                  "title": "5) 操作系统的时钟硬件中断处理函数准备挂起B进程，也就是把寄存器和函数堆栈保存起来，发现B进程收到了singal",
                  "topics": [
                    {
                      "title": "或者其他系统调用, 系统调用,即将回到用户态时,会检查进程的信号,如果需要处理,就处理掉"
                    },
                    {
                      "title": "系统调用、缺页异常、系统中断"
                    }
                  ]
                },
                {
                  "title": "6) 操作系统在保存好B进程的stack和register后，新开stack(为了不干扰B进程真正的代码stack），激活B进程，B进程的信号处理函数"
                }
              ]
            },
            {
              "title": "内核态进程能否 响应中断",
              "topics": [
                {
                  "title": "内核进程是不响应信号的"
                },
                {
                  "title": "因为内核进程不会被切换到用户态,不会去检查信号. 所以一般无法通过kill 杀掉一个内核进程"
                },
                {
                  "title": "面试问题: 你知道的内核进程有哪些, 如何杀掉一个内核进程"
                },
                {
                  "title": "如果响应:需要主动检查",
                  "topics": [
                    {
                      "title": "    if (signal_pending(current))
    {
        // 自定义信号处理函数
    }
    flush_signals(current);"
                    }
                  ]
                }
              ]
            },
            {
              "title": "如果进程被阻塞怎么办",
              "topics": [
                {
                  "title": "分为当前阻塞 可否被中断, 如果可以被中断,则提前返回用户态执行.否则 信号被挂到信号队列等待处理"
                }
              ]
            },
            {
              "title": "如何发送一个信号",
              "topics": [
                {
                  "title": "kill() 系统调用的功能是发送一个信号给线程组，只需要线程组挑出一个线程来响应处理信号。但是对于致命信号，线程组内所有进程都会被杀死，而不仅仅是处理信号的线程"
                },
                {
                  "title": "kill() 是向进程组发一个信号，而 tkill() 是向某一个进程发送信号。",
                  "topics": [
                    {
                      "title": "tkill(pid, sig"
                    }
                  ]
                },
                {
                  "title": "tgkill() 是向特定线程组中的进程发送信号。",
                  "topics": [
                    {
                      "title": "[Image]"
                    }
                  ]
                }
              ]
            },
            {
              "title": "如何阻塞一个信号",
              "topics": [
                {
                  "title": "sigprocmask() 用来设置进程对信号是否阻塞。阻塞以后，信号继续挂载到信号 pending 队列，但是信号处理时不响应信号。SIG_BLOCK 命令阻塞信号，SIG_UNBLOCK 命令解除阻塞信号"
                },
                {
                  "title": "控制何时处理信号"
                }
              ]
            },
            {
              "title": "信号的处理方式",
              "topics": [
                {
                  "title": "[Image]"
                }
              ]
            },
            {
              "title": "常见信号",
              "topics": [
                {
                  "title": "[Image]",
                  "topics": [
                    {
                      "title": "[Image]"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "title": "信号中断虚假唤醒",
          "topics": [
            {
              "title": "如果信号发送到阻塞状态进程,如何响应该信号?",
              "makers": [
                "priority-1",
                "task-done"
              ],
              "topics": [
                {
                  "title": " 因为信号的处理在系统调用返回时, 和中断处理函数(只是处理当前进程的信号)"
                },
                {
                  "title": "进程可以处于 TASK_INTERRUPTIBLE状态即使被挂起,也是可以响应中断的. 即等待信号量,锁, socket事件, 定时器等应该该状态,(大部分挂起都是该状态). 当接收到信号时, 进程会置为Runable状态, 可接收调度, 在被调度执行前, 处理信号.",
                  "makers": [
                    "task-done",
                    "flag-red"
                  ]
                },
                {
                  "title": "可以屏蔽该信号,就不会被唤醒."
                }
              ]
            },
            {
              "title": "所以很多阻塞的系统调用都可能被信号虚假唤醒. 需要在唤醒后, 再次检查.是否真的符合条件. 包括条件变量, 定时器,等.锁需要判断条件是否满足, 定时器看时间是否满足"
            }
          ]
        },
        {
          "title": "为什么异常处理程序 还需要给进程发送信号呢?",
          "topics": [
            {
              "title": "进程可以接收到 除0异常 的信号, 决定如何处理这个信号,默认会终止进程.也可以选择额外的处理"
            },
            {
              "title": "过程是说: cpu在 执行 除0指令时(一般是用户态程序,内核除非是bug才会发生),会触发除0 的异常处理程序.该处理程序会给进程 发送信号, 而后返回(返回时, 会触发调度检查, 信号处理等)"
            },
            {
              "title": "例如缺页异常,缺页异常是cpu发出软中断, 在异常处理程序中, 负责读取相应的页面. 然后返回,或者主动调度(因为读取磁盘会触发阻塞). 到时候IO 设备读取数据后,会触发中断.然后 中断处理会读取相关数据到内核态. 然后 切换进程状态到Runnable. 等到进程再次被调度执行时,继续上一次的指令执行."
            }
          ]
        },
        {
          "title": "常见的内中断,同步中断, 异常",
          "topics": [
            {
              "title": "除0"
            },
            {
              "title": "debug",
              "topics": [
                {
                  "title": "也会发信号"
                }
              ]
            },
            {
              "title": "无效操作码(编译出错)"
            },
            {
              "title": "地址越界等"
            },
            {
              "title": "缺页",
              "topics": [
                {
                  "title": "会给进程发信号"
                }
              ]
            }
          ]
        },
        {
          "title": "异常",
          "topics": [
            {
              "title": "大部分异常只在cpu处于用户态时发生."
            },
            {
              "title": "缺页异常发生在内核态",
              "topics": [
                {
                  "title": "缺页异常可能会导致进程切换."
                },
                {
                  "title": "会挂起当前线程."
                },
                {
                  "title": "缺页异常处理程序不会再进一步引起异常",
                  "topics": [
                    {
                      "title": "不会再出发缺页,导致进程切换"
                    }
                  ]
                }
              ]
            },
            {
              "title": "中断处理程序和异常处理程序的却别",
              "topics": [
                {
                  "title": "中断处理程序是对硬件设备进行中断,例如IO设备, 时钟等. 存在中断上下部分,上半部分不可被中断"
                },
                {
                  "title": "中断处理程序可能会中断异常处理程序,但异常处理程序不会抢占中断处理程序."
                },
                {
                  "title": "中断处理程序等不及通过信号处理. 只能立即处理.至少先记下该中断,让IO设备忙起来.而异常处理函数则通过信号交由进程处理"
                }
              ]
            }
          ]
        },
        {
          "title": "中断上下部分和软中断",
          "topics": [
            {
              "title": "一般情况下，一个中断事件所触发的动作可能需要占用很多CPU时间，但通常其中多数内容都是可以等待的。为了保证对硬件保持较短的响应时间，在一个中断事件到来时，可以先抢占CPU，将必须尽快处理的事情做完，然后释放CPU，在稍后的某一时刻，当内核不需要再做一些紧迫之事，再处理中断事件剩下的事情"
            },
            {
              "title": "这些可以延后的处理程序被称为中断下半部。例如网卡收包的处理，当CPU收到一个收包中断时，需要把数据包从DMA中搬运到内存中内核预先设置好的位置，并设置某些标记来通知内核有数据包到来，然后内核分配一个skb缓冲区，将数据内容拷贝到缓冲区里，并初始化一个skb实例，然后将数据包交给上层协议栈处理，这个过程非常复杂，需要耗费大量CPU时间，不可能都在中断处理程序中完成。有了中断下半部机制，在中断处理程序中只需将数据包放到内存并设好标记，这可以很快完成，而剩下实际的数据包处理过程则放到下半部中去执行。"
            },
            {
              "title": "内核使用软中断（softirq）和微任务（tasklet）两种可延迟函数来实现中断下半部机制，他们是一种非紧迫、可中断的内核函数，因为他们在执行过程是开中断的。"
            },
            {
              "title": "某些软中断例如 缺页中断等cpu生成的内中断,需要立即执行, 某些网络事件也以依赖于软中断, 后续处理,或者放在具体的内核线程中处理即可.",
              "topics": [
                {
                  "title": "ksoftirq内核线程处理软中断,优先级最低, 但是 Cfs 调度算法保证其在每一个调度周期都会被执行一次"
                },
                {
                  "title": "每一个cpu 都会有个ksoftirq线程"
                },
                {
                  "title": "触发软中断事务通过raise_softirq（）来实现，该函数就是在中断关闭的情况下设置软中断状态位，然后判断如果不在中断上下文，那么直接唤醒守护daemon。"
                },
                {
                  "title": "有一些场景其实没有放到内核线程去执行, 例如系统调动, 除 0软中断. 但是网络收发包确实是放到内核线程做的"
                },
                {
                  "title": "在软中断的do_softirq 处理中,会进行循环判断, 当处理完几个软中断后,还依然存在中断,就wakeup_softirq 内核线程处理",
                  "makers": [
                    "priority-2",
                    "task-done"
                  ]
                },
                {
                  "title": "另外do_softirq 在进入前判断, 如果当前处于软中断中, 则直接退出, 这个函数不光会执行自己的软中断,还会执行其他软中断.所以即使硬中断 可以抢占当前执行的软中断, 然后在硬件中断中再次发出中断, 软中断的处理函数也不会发生嵌套, 因为do_softirq 检测当前处理软中断上下文,会直接退出(避免嵌套)",
                  "makers": [
                    "task-done",
                    "flag-red",
                    "week-sun",
                    "month-feb"
                  ],
                  "topics": [
                    {
                      "title": "软中断上下文中通过内核提供的per-cpu 变量提供"
                    }
                  ]
                }
              ]
            },
            {
              "title": "相关函数",
              "topics": [
                {
                  "title": "1、  Open_softirq，注册一个软中断，将软中断服务程序注册到软中断向量表。"
                },
                {
                  "title": "2、  Raise_softirq，设置软中断状态bitmap，触发软中断事务。"
                }
              ]
            },
            {
              "title": "检查状态",
              "topics": [
                {
                  "title": "#define in_interrupt() (irq_count()) // 是否处于中断状态(硬中断或软中断)"
                },
                {
                  "title": "#define in_irq() (hardirq_count()) // 是否处于硬中断"
                },
                {
                  "title": "#define in_softirq() (softirq_count()) // 是否处于软中断"
                }
              ]
            },
            {
              "title": "http://www.voidcn.com/article/p-pzptsiwt-zp.html"
            }
          ]
        },
        {
          "title": "硬件中断",
          "topics": [
            {
              "title": "[Image]"
            },
            {
              "title": "[Image]"
            },
            {
              "title": "可屏蔽中断和不可屏蔽中断",
              "topics": [
                {
                  "title": "[Image]"
                }
              ]
            },
            {
              "title": "同步中断与异步中断",
              "topics": [
                {
                  "title": "1.	同步中断是当指令执行时由 CPU 控制单元产生，之所以称为同步，是因为只有在一条指令执行完毕后 CPU 才会发出中断，而不是发生在代码指令执行期间，比如系统调用是同步中断"
                },
                {
                  "title": "异步中断是指由其他硬件设备依照 CPU 时钟信号随机产生，即意味着中断能够在指令之间发生，例如键盘中断。"
                }
              ]
            },
            {
              "title": "中断和异常",
              "topics": [
                {
                  "title": "中断可分为可屏蔽中断（Maskable interrupt）和非屏蔽中断（Nomaskable interrupt）。异常可分为故障（fault）、陷阱（trap）、终止（abort）三类。"
                },
                {
                  "title": "[Image]",
                  "topics": [
                    {
                      "title": "故障（fault），通常可以纠正，一旦纠正，程序就可以重新开始，保存在eip寄存器中的值是引起故障的指令地址。内存缺页异常.就是这个"
                    },
                    {
                      "title": "陷阱（trap）在陷阱指令执行后立即报告，内核把控制权烦给程序后就可以继续它的执行而不失连续性。保存在eip中的值是一个随后要执行的指令地址。陷阱的主要作用是为了调试程序"
                    },
                    {
                      "title": "异常中止（abort），发生一个严重的错误，控制单元出了问题，不能在eip寄存器中保存引起异常的指令所在的确切位置。异常中止用于报告严重的错误，例如硬件故障或系统表中无效的值或者不一致的值。这种异常会强制中止进程。"
                    },
                    {
                      "title": "编程异常（programmed exception），在编程者发出的请求时发送，是由int或int3指令触发的。",
                      "topics": [
                        {
                          "title": "系统调用"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "title": "中断亲和力",
              "topics": [
                {
                  "title": "中断亲和力是指将一个或多个中断源绑定到特定的 CPU 上运行。"
                },
                {
                  "title": "有啥用",
                  "topics": [
                    {
                      "title": "在网络非常 heavy 的情况下，对于文件服务器、高流量 Web 服务器这样的应用来说，把不同的网卡 IRQ 均衡绑定到不同的 CPU 上将会减轻某个 CPU 的负担，提高多个 CPU 整体处理中断的能力。 对于数据库服务器这样的应用来说，把磁盘控制器绑到一个 CPU、把网卡绑定到另一个 CPU 将会提高数据库的响应时间、优化性能"
                    }
                  ]
                },
                {
                  "title": "网卡多队列,就是为了避免一个队列只绑定到一个cpu,导致队列满了,cpu必须处理, 而且频繁通知一个cpu, 导致网络处理变慢, 或者占用cpu, 当多个队列之后, 可以分散压力给多个cpu."
                }
              ]
            },
            {
              "title": "异常",
              "topics": [
                {
                  "title": "用户在终端 按下某些键时，终端驱动程序会发送信号给前台进程，例如Ctrl-C 产生 SIGINT 信 号， Ctrl-/ 产生 SIGQUIT 信号， Ctrl-Z 产生 SIGTSTP 信号。"
                },
                {
                  "title": "硬件异常产生信号，这些条件由硬件检测到并通知内核，然后内核向当前进程发送适当的信号。例如当前进程执行了 除以0 的指令， CPU 的运算单元会产生异常，内核将这个异常解释为 SIGFPE 信号发送给进 程。再比如当前进程访问了非法内存地址，， MMU 会产生异常，内核将这个异常解释为 SIGSEGV 信 号发送给进程。"
                },
                {
                  "title": "“缺页”也是一个 异常,"
                }
              ]
            },
            {
              "title": "cpu 中断须知",
              "topics": [
                {
                  "title": "[Image]"
                },
                {
                  "title": "何时响应中断",
                  "topics": [
                    {
                      "title": "  ①IF=1(对非屏蔽中断，没有此项要求)；",
                      "topics": [
                        {
                          "title": "cpu可以屏蔽中断"
                        }
                      ]
                    },
                    {
                      "title": "  ②现行指令执行完。"
                    },
                    {
                      "title": "  CPU在每一个指令周期的最后一个总线周期的最后一个时钟周期的开始采样中断请求输入线，若有中断请求，则下一步不进入取指令周期，而进入中断响应周期",
                      "makers": [
                        "priority-1",
                        "task-done"
                      ]
                    },
                    {
                      "title": "每当一个指令执行完都会检查中断, 硬件中断"
                    }
                  ]
                },
                {
                  "title": "硬件中断禁用中断是禁止其他硬件中断. 硬中断被抢占也是其他硬件中断抢占. 同一个中断号不存在抢占"
                }
              ]
            },
            {
              "title": "时钟中断",
              "topics": [
                {
                  "title": "属于硬件中断,时间可能为1ms, 由时钟硬件 支持. 其实是一个性能权衡, 太频繁,系统性能下降."
                },
                {
                  "title": "时钟中断只是一个周期性的信号，完全是硬件行为，该信号触发CPU去执行一个中断服务程序",
                  "topics": [
                    {
                      "title": "cpu每个指令完成后就会去检查硬件中断(指令不可被中断,原子操作)"
                    }
                  ]
                },
                {
                  "title": "在Linux的0号中断是一个定时器中断。在固定的时间间隔都发生一次中断，也是说每秒发生该中断的频率都是固定的。该频率是常量HZ，该值一般是在100 ~ 1000之间。该中断的作用是为了定时更新系统日期和时间，使系统时间不断地得到跳转。另外该中断的中断处理函数除了更新系统时间外，还需要更新本地CPU统计数。指的是调用scheduler_tick递减进程的时间片，若进程的时间片递减到0，进程则被调度出去而放弃CPU使用权。",
                  "topics": [
                    {
                      "title": "时钟中断和调度息息相关, cfs算法中进程红黑树的更新依赖于时钟中断, 包括实时进程调度的轮训和FIFO都依赖于时钟中断更新时间片."
                    }
                  ]
                },
                {
                  "title": "作用",
                  "topics": [
                    {
                      "title": "更新时间片, 触发软件时钟,执行调度, 信号处理等."
                    }
                  ]
                },
                {
                  "title": "软件时钟",
                  "topics": [
                    {
                      "title": "“软件时钟”指的是软件定时器（Software Timers），是一个软件上的概念，是建立在硬件时钟基础之上的。它记录了未来某一时刻要执行的操作（函数），并使得当这一时刻真正到来时，这些操作（函数）能够被按时执行。举个例子说明：它就像生活中的闹铃，给闹铃设定振铃时间（未来的某一时间）后，当时间（相当于硬件时钟）更新到这个振铃时间后，闹铃就会振铃。这个振铃时间好比软件时钟的到期时间，振铃这个动作好比软件时钟到期后要执行的函数，而闹铃时间更新好比硬件时钟的更新。"
                    },
                    {
                      "title": "实现软件时钟原理也比较简单：每一次硬件时钟中断到达时，内核更新的 jiffies ，然后将其和软件时钟的到期时间进行比较。如果 jiffies 等于或者大于软件时钟的到期时间，内核就执行软件时钟指定的函数"
                    },
                    {
                      "title": "作用",
                      "topics": [
                        {
                          "title": "大部分设备驱动程序使用软件时钟探测异常条件、"
                        },
                        {
                          "title": "进程的定时睡眠（ schedule_timeout 函数）",
                          "topics": [
                            {
                              "title": "主动将自己挂起,注册定时器,然后放弃cpu, 触发调度."
                            },
                            {
                              "title": "定时器到期时, 自己注册的定时器处理函数将 自己唤醒."
                            },
                            {
                              "title": "sleep, pause都可以实现定时."
                            }
                          ]
                        },
                        {
                          "title": "网络超时重传"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "title": "软中断和硬中断的区别",
              "topics": [
                {
                  "title": "硬中断是有外设硬件发出的，需要有中断控制器之参与。其过程是外设侦测到变化，告知中断控制器，中断控制器通过CPU或内存的中断脚通知CPU，然后硬件进行程序计数器及堆栈寄存器之现场保存工作（引发上下文切换），并根据中断向量调用硬中断处理程序进行中断处理"
                },
                {
                  "title": "软中断则通常是由硬中断处理程序或者进程调度程序等软件程序发出的中断信号，无需中断控制器之参与，直接以一个CPU指令之形式指示CPU进行程序计数器及堆栈寄存器之现场保存工作(亦会引发上下文切换)，并调用相应的软中断处理程序进行中断处理(例如系统调用就是利用软中断)"
                },
                {
                  "title": "硬中断直接以硬件的方式引发，处理速度快。软中断以软件指令之方式适合于对响应速度要求不是特别严格的场景, 一般是在硬件中断的处理程序中 触发软中断. 软中断是 非紧急可延迟的中断处理. "
                },
                {
                  "title": "硬中断通过设置CPU的屏蔽位可进行屏蔽，软中断则由于是指令之方式给出，不能屏蔽"
                },
                {
                  "title": "硬中断发生后，通常会在硬中断处理程序中调用一个软中断来进行后续工作的处理"
                },
                {
                  "title": "硬中断和软中断均会引起上下文切换(进程/线程之切换)，进程切换的过程是差不多的",
                  "topics": [
                    {
                      "title": "硬中断 上半部分不可被中断, 所以时间应该非常短."
                    }
                  ]
                },
                {
                  "title": "可以通过软中断指令,触发中断.例如系统调用就是通过软中断触发的. 内核在中断处理函数处作为系统调用入口, 其他也可以用软中断实现. 例如缺页异常, 通过软中断, 处理.. 然后返回继续执行下一条指令. 软中断和信号没有必然关系, 信号也不是软中断. 信号是进程间或内核与进程间通知的一种机制. "
                },
                {
                  "title": "硬中断可以抢占 软中断, 软中断不能抢占软中断和硬中断"
                },
                {
                  "title": "软中断是cpu内部产生的,也可以由cpu指令触发, 或缺页等操作. "
                },
                {
                  "title": "int是软中断指令。中断向量表是中断号和中断处理函数地址的对应表。int n - 触发软中断n。相应的中断处理函数的地址为：中断向量表地址 + 4 * n。",
                  "topics": [
                    {
                      "title": "软中断就是具体的cpu指令."
                    }
                  ]
                },
                {
                  "title": "软中断是执行中断指令产生的，而硬中断是由外设引发的。"
                },
                {
                  "title": "软中断不可以嵌套. 只能一个个执行.也就是一个cpu 上只会有一个软中断在执行. 即使中间发生硬中断.软中断也会靠后执行. 同一个软中断可以在多个cpu 上并行. 一个硬中断只能被另一个类型的硬中断抢占,也就是嵌套."
                }
              ]
            }
          ]
        },
        {
          "title": "何时发生内核态到用户的切换, 这个过程都发生了什么",
          "topics": [
            {
              "title": "系统调用返回函数, 它是从中断、异常及系统调用返回时的通用接口",
              "makers": [
                "task-done",
                "priority-1"
              ]
            },
            {
              "title": "检测是否需要重新调度",
              "topics": [
                {
                  "title": "检测调度标志need_resched，决定是否要执行调度程序；"
                },
                {
                  "title": "不负责更新这个字段,这个字段放在其他地方更新"
                }
              ]
            },
            {
              "title": "处理当前进程接收到的信号"
            },
            {
              "title": "处理虚拟86模式下当前进程接收到的信号"
            },
            {
              "title": "RESTORE_ALL我们把这个函数叫做彻底返回函数，因为执行该函数之后，就返回到当前进程的地址空间中去了"
            },
            {
              "title": "在一个进程被调度的前夕 执行该进程的信号处理. 如果该进程执行了这个函数,但是没有发生进程切换,那么也可能处理信号. 在时钟中断返回时, 需要检查调度和信号. 系统调用返回时,也需要检查, 所以触发时机 可以是中断,异常和系统调用. "
            }
          ]
        }
      ]
    },
    "structure": "org.xmind.ui.map.unbalanced"
  }
]