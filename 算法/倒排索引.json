[
  {
    "title": "画布 1",
    "topic": {
      "title": "倒排索引",
      "topics": [
        {
          "title": "淘气三千问",
          "topics": [
            {
              "title": "为什么叫做倒排索引",
              "topics": [
                {
                  "title": "英文原名Inverted index",
                  "topics": [
                    {
                      "title": "inverted 倒置的"
                    }
                  ]
                },
                {
                  "title": "一个未经处理的数据库中，一般是以文档ID作为索引，以文档内容作为记录。而Inverted index 指的是将单词或记录作为索引，将文档ID作为记录，这样便可以方便地通过单词或记录查找到其所在的文档。"
                }
              ]
            }
          ]
        },
        {
          "title": "profile",
          "topics": [
            {
              "title": "文件结构",
              "topics": [
                {
                  "title": "带有倒排索引的文件我们称为倒排索引文件，简称倒排文件(inverted file)。"
                },
                {
                  "title": "所有单词的倒排列表顺序的存储在磁盘的某个文件里，这个文件即被称为倒排文件，倒排文件是存储倒排索引的物理文件"
                },
                {
                  "title": "单词词典",
                  "topics": [
                    {
                      "title": "单词词典是由文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引项记载单词本身的一些信息以及指向“倒排列表”的指针。"
                    },
                    {
                      "title": "单词词典是倒排索引中非常重要的组成部分，它是用来维护文档集合中所有单词的相关信息，同时用来记载某个单词对应的倒排列表在倒排文件中的位置信息。在支持搜索时，根据用户的查询词，去单词词典里查询，就能够获得相应的倒排列表"
                    },
                    {
                      "title": "常用的数据结构包含哈希加链表和树形词典结构。"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "title": "倒排实现步骤",
          "topics": [
            {
              "title": "1.用分词系统将文档自动切分成单词序列。"
            },
            {
              "title": "2.对每个不同的单词赋予唯一的单词编号，并记录下哪些文档包含这个单词。"
            },
            {
              "title": "3.还可以记录单词频率（TF），代表这个单词在某个文档中出现的次数。因为词频信息在搜索结果排序时，是计算查询和文档相似度的一个很重要的计算因子。",
              "topics": [
                {
                  "title": "[Image]"
                }
              ]
            },
            {
              "title": "4.实用的倒排索引还可以额外记录两类信息：每个单词对应的文档频率信息（DF，文档集合中有多少个文档包含了这个单词），及单词在某个文档中出现的位置信息（POS）",
              "topics": [
                {
                  "title": "[Image]"
                }
              ]
            }
          ]
        },
        {
          "title": "搜索实现步骤",
          "topics": [
            {
              "title": "在响应用户查询请求时，其过程与建立词典类似，不同点在于即使词典里没出现过某个单词，也不会添加到词典内。"
            },
            {
              "title": "以图1-7为例，假设用户输入的查询请求为单词3，对这个单词进行哈希，定位到哈希表内的2号槽，"
            },
            {
              "title": "从其保留的指针可以获得冲突链表，依次将单词3和冲突链表内的单词比较，发现单词3在冲突链表内，于是找到这个单词"
            },
            {
              "title": "读出这个单词对应的倒排列表来进行后续的工作，如果没有找到这个单词，说明文档集合内没有任何文档包含单词，则搜索结果为空。"
            }
          ]
        },
        {
          "title": "索引更新策略",
          "topics": [
            {
              "title": "完全重建策略",
              "topics": [
                {
                  "title": "当新增文档到达一定数目的时候，将新增文档和老文档进行合并，然后对所有文档重新建立索引。这是目前主流搜索引擎采用的方法"
                }
              ]
            },
            {
              "title": "再合并策略",
              "topics": [
                {
                  "title": "达到一定条件后，将临时索引和老文档的倒排索引进行合并，以生成新的索引"
                }
              ]
            },
            {
              "title": "原地更新策略",
              "topics": [
                {
                  "title": "为了改进再合并策略的缺点，即在索引更新过程中，如果老索引的倒排列表没有变化，那就可以不需要读取这些信息，只在其末尾进行追加。"
                },
                {
                  "title": "破坏了单词索引的连续性，因为不可能预留无限大的空间使其可以一直往后追加，所以就必须做数据迁移，这样导致了进行索引合并时不能顺序读取，反而降低了磁盘读取速度，而且还需要大量的内存来记录位置的对应关系",
                  "makers": [
                    "task-done",
                    "priority-1",
                    "star-red"
                  ]
                }
              ]
            },
            {
              "title": "混合策略",
              "topics": [
                {
                  "title": "针对不同类别的单词，对其索引采取不同的索引更新策略。比如，倒排列表较长的单词用原地更新策略，短倒排列表单词则采取再合并策略"
                }
              ]
            }
          ]
        },
        {
          "title": "单词词典如何实现",
          "topics": [
            {
              "title": "哈希加链表",
              "topics": [
                {
                  "title": "在解析一个新文档的时候，对于某个在文档中出现的单词T，首先利用哈希函数获得其哈希值，之后根据哈希值对应的哈希表项读取其中保存的指针，就找到了对应的冲突链表。"
                },
                {
                  "title": "如果冲突链表里已经存在这个单词，说明单词在之前解析的文档里已经出现过。"
                },
                {
                  "title": "如果在冲突链表里没有发现这个单词，说明该单词是首次碰到，则将其加入冲突链表里。通过这种方式，当文档集合内所有文档解析完毕时，相应的词典结构也就建立起来了。"
                }
              ]
            },
            {
              "title": "树形结构",
              "topics": [
                {
                  "title": "B树与哈希方式查找不同，需要字典项能够按照大小排序（数字或者字符序），而哈希方式则无须数据满足此项要求。"
                },
                {
                  "title": "B树形成了层级查找结构，中间节点用于指出一定顺序范围的词典项目存储在哪个子树中，起到根据词典项比较大小进行导航的作用，最底层的叶子节点存储单词的地址信息，根据这个地址就可以提取出单词字符串",
                  "topics": [
                    {
                      "title": "[Image]"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "title": "查询时 排序策略",
          "topics": [
            {
              "title": "一次一文档",
              "topics": [
                {
                  "title": "搜索引擎接收到用户的查询后，首先将两个单词的倒排列表从磁盘读入内存，以倒排表中包含的文档为单位，每次将其中某个文档与查询的最终相似性计算完毕，然后开始计算另外一个文档的最终得分，知道所有的文档都计算完毕为止。"
                },
                {
                  "title": "在计算过程中始终保留得分最高的K个文档即可。"
                },
                {
                  "title": "将所有单词的文档全部查出来, 以文档为单位, 计算分数"
                }
              ]
            },
            {
              "title": "一次一单词",
              "topics": [
                {
                  "title": "一次一单词方式首先将某个单词对应的倒排列表中的每个文档ID都计算一个部分相似性得分，待计算下个单词的倒排列表时，对于每个文档，在原先得分基础上进行累加。当所有单词都处理完毕后，每个文档的最终相似性得分计算结束，之后输出得分最高的K个文档作为搜索结果"
                },
                {
                  "title": "以搜索关键词的分词为基本单位. 每次计算一个分词对应文档的得分, 所有分词计算完, 就可以得出全部的得分."
                }
              ]
            }
          ]
        }
      ]
    },
    "structure": "org.xmind.ui.map.unbalanced"
  }
]