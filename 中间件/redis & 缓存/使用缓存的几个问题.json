[
  {
    "title": "画布 1",
    "topic": {
      "title": "使用缓存的几个问题",
      "topics": [
        {
          "title": "缓存预热",
          "topics": [
            {
              "title": "全量刷新缓存",
              "topics": [
                {
                  "title": "系统上线后，将相关的缓存数据直接加载到缓存系统。
防止刚上线时 大量请求击穿缓存"
                }
              ]
            },
            {
              "title": "加互斥锁",
              "topics": [
                {
                  "title": "对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询"
                },
                {
                  "title": "适用于某些个别热点数据 访问多. 当大量访问不同数据时依然不生效"
                }
              ]
            }
          ]
        },
        {
          "title": "缓存击穿等",
          "topics": [
            {
              "title": "缓存大量过期导致雪崩",
              "topics": [
                {
                  "title": "指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉"
                },
                {
                  "title": "侧重于缓存本身过期"
                },
                {
                  "title": "缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生"
                }
              ]
            },
            {
              "title": "缓存穿透",
              "topics": [
                {
                  "title": "指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉"
                },
                {
                  "title": "恶性访问不存在数据, 击穿缓存,打垮数据库"
                },
                {
                  "title": "应对措施",
                  "topics": [
                    {
                      "title": "接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截"
                    },
                    {
                      "title": "从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null"
                    },
                    {
                      "title": "采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力"
                    }
                  ]
                }
              ]
            },
            {
              "title": "缓存击穿",
              "topics": [
                {
                  "title": "指缓存中没有但数据库中有的数据（一般是缓存时间到期）"
                },
                {
                  "title": "这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力"
                },
                {
                  "title": "和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。"
                },
                {
                  "title": "应对方案",
                  "topics": [
                    {
                      "title": "设置热点数据永远不过期。"
                    },
                    {
                      "title": "加互斥锁，互斥锁"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "title": "缓存一致性问题",
          "topics": [
            {
              "title": "先更新数据库,再删除缓存",
              "topics": [
                {
                  "title": "（1）缓存刚好失效
（2）请求A查询数据库，得一个旧值
（3）请求B将新值写入数据库
（4）请求B删除缓存
（5）请求A将查到的旧值写入缓存",
                  "topics": [
                    {
                      "title": "以上会发生脏数据"
                    }
                  ]
                },
                {
                  "title": "但是只有2,3中 3比2 快, B才会发生先删除缓存,A 用旧值写缓存"
                },
                {
                  "title": "实际上 写库操作远远低于读操作,所以避免慢 SQL."
                }
              ]
            },
            {
              "title": "先删缓存再写数据库",
              "topics": [
                {
                  "title": "（1）先淘汰缓存
（2）再写数据库（这两步和原来一样）
（3）休眠1秒，再次淘汰缓存"
                },
                {
                  "title": "使用异步双删除"
                }
              ]
            },
            {
              "title": "可以使用双删除策略. 即 删除, 写库, 再删除"
            }
          ]
        }
      ]
    },
    "structure": "org.xmind.ui.map.unbalanced"
  }
]