[
  {
    "title": "画布 1",
    "topic": {
      "title": "Java 锁和线程",
      "topics": [
        {
          "title": "自旋锁",
          "topics": [
            {
              "title": "自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁
的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等(自旋)，
等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。"
            },
            {
              "title": "如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁
 的线程在最大等待时间内还是获取不到锁，这时争用线程"
            },
            {
              "title": "基本认为一个线程上下文切换的时间是最佳的一个时间",
              "makers": [
                "flag-red"
              ]
            }
          ]
        },
        {
          "title": "Synchronized",
          "topics": [
            {
              "title": "[Image]"
            },
            {
              "title": "JVM 每次从队列的尾部取出一个数据用于锁竞争候选者(OnDeck)，但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。"
            },
            {
              "title": "Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定EntryList 中的某个线程为 OnDeck 线程(一般是最先进去的那个线程)。"
            },
            {
              "title": "Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM 中，也把这种选择行为称之为“竞争切换”。"
            },
            {
              "title": "OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList"
            },
            {
              "title": "中。如果 Owner 线程被 wait 方法阻塞，则转移到 WaitSet 队列中，直到某个时刻通过 notify或者 notifyAll 唤醒，会重新进去 EntryList 中。"
            },
            {
              "title": "处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的(Linux 内核下采用 pthread_mutex_lock 内核函数实现的)。"
            },
            {
              "title": "Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁"
            },
            {
              "title": "每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的"
            },
            {
              "title": "synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。"
            },
            {
              "title": "Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。"
            },
            {
              "title": "锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀;JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁。"
            }
          ]
        },
        {
          "title": "ReentrantLock",
          "topics": [
            {
              "title": "ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要使用 ReentrantLock。"
            },
            {
              "title": "tryLock 能获得锁就返回 true，不能就立即返回 false，tryLock(long timeout,TimeUnitunit)，可以增加时间限制，如果超过该时间段还没获得锁，返回 falselock 能获得锁就返回 true，不能的话一直等待获得锁"
            },
            {
              "title": "lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程，lock 不会抛出异常，而 lockInterruptibly 会抛出异常。",
              "topics": [
                {
                  "title": "在等待临界资源的过程中可以被Thread.interrupt()方法中断。"
                }
              ]
            }
          ]
        },
        {
          "title": "lock和 synchronized区别",
          "topics": [
            {
              "title": "语言层面,虚拟机层面"
            },
            {
              "title": "lock可以公平性,中断,可超时, 多个条件变量."
            },
            {
              "title": "sync可以得到虚拟机的优化,例如 偏向锁, 轻量级锁. "
            }
          ]
        },
        {
          "title": "线程中断",
          "topics": [
            {
              "title": "线程中断是一种协作机制,并未一个线程对另一个线程的强制操作",
              "topics": [
                {
                  "title": "中断是一种协作机制。当一个线程中断另一个线程时，被中断的线程不一定要立即停止正在做的事情。相反，中断是礼貌地请求另一个线程在它愿意并且方便的时候停止它正在做的事情。有些方法，例如 Thread.sleep()，很认真地对待这样的请求，但每个方法不是一定要对中断作出响应。"
                },
                {
                  "title": "我们很少希望一个活动立即停止；如果活动在正在进行更新的时候被取消，那么程序数据结构可能处于不一致状态。中断允许一个可取消活动来清理正在进行的工作，恢复不变量，通知其他活动它要被取消，然后才终止。"
                },
                {
                  "title": "对于中断请求，不阻塞但是仍然要花较长时间执行的方法可以轮询中断状态，并在被中断的时候提前返回。 您可以随意忽略中断请求，但是这样做的话会影响响应。"
                },
                {
                  "title": "对中断的响应不一定要抛出异常, 可以商定业务层的处理,例如特殊的返回值, 特殊的异常等等,
将中断作为 任务处理失败的异常类型之一, 由业务层统一处理该类任务执行失败. "
                }
              ]
            },
            {
              "title": "不正确的中断处理机制可能导致 应用程序丧失及时取消活动或关闭的能力。",
              "makers": [
                "priority-1",
                "flag-red"
              ],
              "topics": [
                {
                  "title": "当服务实现了优雅关闭,即在退出时,向所有线程发出中断请求,这时,如果 有线程没有有效处理
中断,即没有响应中断,或者接到下层的中断响应,但是忽略到了,将会导致 任务无法完美关闭的风险."
                },
                {
                  "title": "中断一个运行在线程池中的任务可以起到双重效果，一是取消任务，二是通知执行线程线程池正要关闭

不要吞掉该中断异常,然后设呢么都不做",
                  "makers": [
                    "priority-1"
                  ]
                }
              ]
            },
            {
              "title": "中断和阻塞",
              "topics": [
                {
                  "title": "阻塞方法特指那些依赖于外部条件的例如 IO,锁等,这些条件并不会导致 CPU 负载,但是使得线程处于 阻塞状态
且条件并不一定肯定可以得到满足,甚至会出现超时现象. 阻塞方法对于程序的关闭响应是一个挑战.

要求阻塞方法能否放弃阻塞立即响应中断. 或者忽略中断,从人物返回. 例如 sleep, wait 等,这些阻塞方法,会立即
退出阻塞,抛出 InterruptedException . 告知上层调用方,自己响应了中断. "
                },
                {
                  "title": "InterrputException 是中断响应的一种, 通过抛出异常的方式告知上游系统自己响应了中断,
jdk, sleep ,锁相关都默认了这种方式,我们也可以采用这个习惯,响应中断"
                },
                {
                  "title": "阻塞方法的编写",
                  "topics": [
                    {
                      "title": "阻塞方法通常在入口就立即轮询中断状态"
                    },
                    {
                      "title": "阻塞方法为 Thread类的一部分,或者确认上游系统 不会关注 中断,自己忽略就可以了,任务有单独的取消机制

惟一可以生吞中断的时候是您知道线程正要退出。只有当调用可中断方法的类是 Thread 的一部分，而不是 Runnable 或通用库代码的情况下，才会发生这样的场景",
                      "makers": [
                        "priority-1"
                      ]
                    },
                    {
                      "title": "调用了阻塞方法的方法也是阻塞方法,即使"
                    },
                    {
                      "title": "即使该任务不可被取消,也应该标记该中断位, 避免上层调用不能响应中断."
                    }
                  ]
                }
              ]
            },
            {
              "title": "响应 InteruptException 的方式",
              "topics": [
                {
                  "title": "不捕获 该异常,向上抛"
                },
                {
                  "title": "捕获该异常,  作一些清理理,向上抛"
                },
                {
                  "title": "捕获该异常,但是不抛出, 重新将其中断位标记为 true, 调用 interrupt方法",
                  "makers": [
                    "priority-1"
                  ],
                  "topics": [
                    {
                      "title": "该异常属于未检查异常, 在某些接口(Runnable)中无法向上抛出"
                    }
                  ]
                }
              ]
            },
            {
              "title": "中断位默认为 false,调用 interrupt 中断线程, 

interrupted 判断是否中断(true )并且取消中断标记, 

isInterrupted判断是否发生了中断"
            },
            {
              "title": "https://www.ibm.com/developerworks/cn/java/j-jtp05236.html"
            }
          ]
        },
        {
          "title": "线程退出",
          "topics": [
            {
              "title": "[Image]"
            },
            {
              "title": null,
              "topics": [
                {
                  "title": "正常退出时, 会调用shutdownHookHandler
并且会等待其他非守护线程结束 才退出程序",
                  "makers": [
                    "priority-1",
                    "flag-red",
                    "star-red"
                  ],
                  "topics": [
                    {
                      "title": "Junit单元测试存在坑点,主函数返回时, 外部调用会直接调用 System.exit 退出程序
单测中创建的线程不会被等待结束,会直接退出",
                      "makers": [
                        "priority-1",
                        "flag-red",
                        "star-red"
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "title": "当调用 System.exit, kill 时,其他线程不会被等待结束,正在阻塞中的线程也不会被中断,而是直接被干掉
所以要注册钩子,在进程退出时,中断其他线程,等待其他线程结束.

等待的前提是该任务可以被取消,或者设置等待时间,过期则不继续等待该线程"
            },
            {
              "title": "kill,System.exit只会生效一次,即多次 kill 一个进程,jvm 会忽略掉"
            },
            {
              "title": "关闭钩子注意",
              "topics": [
                {
                  "title": "关闭钩子本质上是一个线程（也称为Hook线程），对于一个JVM中注册的多个关闭钩子它们将会并发执行，所以JVM并不保证它们的执行顺序；由于是并发执行的，那么很可能因为代码不当导致出现竞态条件或死锁等问题，为了避免该问题，强烈建议在一个钩子中执行一系列操作。"
                },
                {
                  "title": "Hook线程会延迟JVM的关闭时间，这就要求在编写钩子过程中必须要尽可能的减少Hook线程的执行时间，避免hook线程中出现耗时的计算、等待用户I/O等等操作。"
                },
                {
                  "title": "关闭钩子执行过程中可能被强制打断,比如在操作系统关机时，操作系统会等待进程停止，等待超时，进程仍未停止，操作系统会强制的杀死该进程，在这类情况下，关闭钩子在执行过程中被强制中止。"
                },
                {
                  "title": "在关闭钩子中，不能执行注册、移除钩子的操作，JVM将关闭钩子序列初始化完毕后，不允许再次添加或者移除已经存在的钩子，否则JVM抛出 IllegalStateException。",
                  "topics": [
                    {
                      "title": "钩子函数中进行 钩子注册等操作,会抛异常"
                    }
                  ]
                },
                {
                  "title": "不能在钩子调用System.exit()，否则卡住JVM的关闭过程，但是可以调用Runtime.halt()。"
                },
                {
                  "title": "Hook线程中同样会抛出异常，对于未捕捉的异常，线程的默认异常处理器处理该异常，不会影响其他hook线程以及JVM正常退出。"
                }
              ]
            }
          ]
        },
        {
          "title": "锁粗化",
          "topics": [
            {
              "title": "通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完
公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步
和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。"
            },
            {
              "title": "当所粒度过于细,会导致大量的锁访问,也会造成大量的性能损失"
            }
          ]
        },
        {
          "title": "锁分离",
          "topics": [
            {
              "title": "最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互
斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发 Java 五]
JDK 并发包 1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。
比如LinkedBlockingQueue 从头部取出，从尾部放数据"
            }
          ]
        },
        {
          "title": "分段锁",
          "topics": [
            {
              "title": "分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践"
            },
            {
              "title": "将大对象(这个对象可能会被很多线程访问)，拆成小对象，大大增加并行度，降低锁竞争。 降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是"
            },
            {
              "title": "  只用在有线程安全要求的程序上加锁"
            }
          ]
        },
        {
          "title": "轻量级锁",
          "topics": [
            {
              "title": "锁的状态总共有四种:无锁状态、偏向锁、轻量级锁和重量级锁。"
            },
            {
              "title": "轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。"
            },
            {
              "title": "轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量"
            },
            {
              "title": "级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。"
            }
          ]
        },
        {
          "title": "偏向锁",
          "topics": [
            {
              "title": "偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入(CAS)的开销，看起来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换ThreadID 的时候依赖一次 CAS 原子指令(由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗)。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。"
            },
            {
              "title": "偏向锁是在一个线程多次获取锁操作时,避免 轻量锁的多次 CAS 操作,进行的优化,只需要一次 cas检查thread id即可"
            }
          ]
        },
        {
          "title": "如何实现公平",
          "topics": [
            {
              "title": "那如何能保证每个线程都能拿到锁呢，队列FIFO是一个完美的解决方案，也就是先进先出"
            },
            {
              "title": "在公平的锁中，如果有另一个线程持有锁或者有其他线程在等待队列中等待这个所，那么新发出的请求的线程将被放入到队列中。而非公平锁上，只有当锁被某个线程持有时，新发出请求的线程才会被放入队列中（此时和公平锁是一样的）。所以，它们的差别在于非公平锁会有更多的机会去抢占锁。"
            },
            {
              "title": "在一个锁释放之后，其他的线程会需要重新来获取锁。其中经历了持有锁的线程释放锁，其他线程从挂起恢复到RUNNABLE状态，其他线程请求锁，获得锁，线程执行，这一系列步骤。如果这个时候，存在一个线程直接请求锁，可能就避开挂起到恢复RUNNABLE状态的这段消耗，所以性能更优化",
              "makers": [
                "priority-1",
                "c_symbol_like"
              ]
            }
          ]
        }
      ]
    },
    "structure": "org.xmind.ui.map.unbalanced"
  }
]