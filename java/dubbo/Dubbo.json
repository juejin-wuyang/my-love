[
  {
    "title": "画布 1",
    "topic": {
      "title": "Dubbo",
      "topics": [
        {
          "title": "分布式改造背景及痛点",
          "topics": [
            {
              "title": "手动配置服务提供地址+ F5",
              "topics": [
                {
                  "title": "负载均衡"
                },
                {
                  "title": "需要服务发现"
                }
              ]
            },
            {
              "title": "背景",
              "topics": [
                {
                  "title": "服务越来越多, URL配置管理非常困难"
                },
                {
                  "title": "服务依赖关系错综复杂"
                },
                {
                  "title": "服务容量规划问题"
                }
              ]
            },
            {
              "title": "服务容量监控",
              "topics": [
                {
                  "title": "需要监控中心"
                }
              ]
            },
            {
              "title": "服务调用错综复杂,依赖关系难以梳理",
              "topics": [
                {
                  "title": "服务治理"
                }
              ]
            }
          ]
        },
        {
          "title": "集群容错",
          "topics": [
            {
              "title": "调用失败",
              "topics": [
                {
                  "title": "失败自动切换，当出现失败，重试其它服务器",
                  "topics": [
                    {
                      "title": "Failover",
                      "topics": [
                        {
                          "title": "默认策略"
                        }
                      ]
                    }
                  ]
                },
                {
                  "title": "快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。",
                  "topics": [
                    {
                      "title": "Failfast"
                    }
                  ]
                },
                {
                  "title": "失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。",
                  "topics": [
                    {
                      "title": "Failback"
                    }
                  ]
                },
                {
                  "title": "并行调用多个服务器，只要一个成功即返回",
                  "topics": [
                    {
                      "title": "Forking"
                    }
                  ]
                },
                {
                  "title": "广播调用所有提供者，逐个调用，任意一台报错则报错 2。通常用于通知所有提供者更新缓存 或日志等本地资源信息"
                },
                {
                  "title": "失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。",
                  "topics": [
                    {
                      "title": "Failsafe"
                    }
                  ]
                }
              ]
            },
            {
              "title": "负载均衡",
              "topics": [
                {
                  "title": "随机，按权重设置随机概率。
  在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较
  均匀，有利于动态调整提供者权重"
                },
                {
                  "title": "轮循，按公约后的权重设置轮循比率。
  存在慢的提供者累积请求的问题，比如:第二台机器很慢，但没挂，当请求调到第二台
  时就卡在那，久而久之，所有请求都卡在调到第二台上。"
                },
                {
                  "title": "最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。
  使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。"
                },
                {
                  "title": "一致性 Hash，相同参数的请求总是发到同一提供者。 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者， 不会引起剧烈变动。"
                }
              ]
            }
          ]
        },
        {
          "title": "线程模型",
          "topics": [
            {
              "title": "对于Dubbo的服务提供者，主要有两种线程池，一种是IO处理线程池，另一种是服务调用线程池。而作为IO处理线程池，由于Dubbo基于Mina、Grizzly和Netty框架做IO组件，IO线程池都是基于这些框架来配置"
            },
            {
              "title": "请求处理会包含三部分：请求解析、服务调用和应答。请求解析需要确认请求的正确性，比如请求解码（比如协议是否正确）、请求是否合法（提供者端是否有该服务；该服务是否需要token验证来防止绕过注册中心直连）；服务调用过程就是提供者作为服务端的一个服务处理过程，这个过程需要用到前面说到的第二种服务调用线程池来执行，该过程通过线程池来和请求解析过程分开，这样做的目的一是过程解耦，二是可以做到服务提供者超时返回，为了让用户能对该过程进行拦截，Dubbo特意通过SPI实现了Filter机制，用户可以通过自定义Filter来对服务调用进行日志记录和监控，当然前提是服务调用线程池还没被请求打满；应答过程主要是对结果进行编码并返回。"
            },
            {
              "title": "如果事件处理的逻辑能迅速完成，并且不会发起新的 IO 请求，比如只是在内存中记个标识， 则直接在 IO 线程上处理更快，因为减少了线程池调度。
但如果事件处理逻辑较慢，或者需要发起新的 IO 请求，比如需要查询数据库，则必须派发到 线程池，否则 IO 线程阻塞，将导致不能接收其它请求。
如果用 IO 线程处理事件，又在事件处理过程中发起新的 IO 请求，比如在连接事件中发起登 录请求，会报“可能引发死锁”异常，但不会真死锁。"
            },
            {
              "title": "all 所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等。 direct 所有消息都不派发到线程池，全部在 IO 线程上直接执行。
message 只有请求响应消息派发到线程池，其它连接断开事件，心跳等消息，直接在 IO
线程上执行。
execution 只请求消息派发到线程池，不含响应，响应和其它连接断开事件，心跳等消
息，直接在 IO 线程上执行。
connection 在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到
线程池。 ThreadPool
fixed 固定大小线程池，启动时建立线程，不关闭，一直持有。(缺省)
cached 缓存线程池，空闲一分钟自动删除，需要时重建。
limited 可伸缩线程池，但池中的线程数只会增长不会收缩。只增长不收缩的目的是为
  了避免收缩时突然来了大流量引起的性能问题。"
            }
          ]
        },
        {
          "title": "架构设计思路",
          "topics": [
            {
              "title": "[Image]"
            }
          ]
        },
        {
          "title": "一些实践",
          "topics": [
            {
              "title": "建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的 一部分，同时，这样做也符合分包原则:重用发布等价原则(REP)，共同重用原则(CRP)"
            },
            {
              "title": "接口设计原则",
              "topics": [
                {
                  "title": "服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将地面临分布式事务问题"
                },
                {
                  "title": "服务接口建议以业务场景为单位划分，并对相近的业务做抽象,防止接口数量爆增(爆炸)。"
                },
                {
                  "title": "不建议使用过于抽象的通用接口，如Map query(Map),这样的接口没有明确语义，会给后期维护带来不便"
                },
                {
                  "title": "每个接口应定义版本号，为后续不兼容升级提供可能"
                }
              ]
            },
            {
              "title": "接口兼容性",
              "topics": [
                {
                  "title": "服务接口增加方法，或服务模型增加字段，可向后兼容；"
                },
                {
                  "title": "删除方法或删除字段，将不兼容，枚举类型新增字段也不兼容，需要通过变更版本号升级。"
                }
              ]
            },
            {
              "title": "异常处理",
              "topics": [
                {
                  "title": "建议使用异常汇报错误，而不是返回错误码，异常信息能携带更多的信息，以及语义更友好。"
                },
                {
                  "title": "查询方法不建议抛出checked异常，否则调用 方在查询 时将过多的try...catch,并且不能进行有效处理。"
                },
                {
                  "title": "服务提供方不应将DAO或者SQL等异常抛给消费方，应在服务实现中对消费方不关心的异常进行包装，否则可能出现消费方无法反序列化相应异常必要的接口输入参数校验"
                }
              ]
            }
          ]
        },
        {
          "title": "dubbo 启动顺序",
          "topics": [
            {
              "title": "注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动
  时与注册中心交互，注册中心不转发请求，压力较小
  监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送
  到监控中心服务器，并以报表展示
  服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含
  网络开销
  服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同
  时汇报调用时间到监控中心，此时间包含网络开销
  注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外
  注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事
  件通知消费者
  注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了
  提供者列表
  注册中心和监控中心都是可选的，服务消费者可以直连服务提供者"
            },
            {
              "title": "1. 服务容器负责启动，加载，运行服务提供者。"
            },
            {
              "title": "2. 服务提供者在启动时，向注册中心注册自己提供的服务。"
            },
            {
              "title": "3. 服务消费者在启动时，向注册中心订阅自己所需的服务。"
            },
            {
              "title": "4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。"
            },
            {
              "title": "5. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如  果调用失败，再选另一台调用。"
            },
            {
              "title": "6. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心"
            }
          ]
        }
      ]
    },
    "structure": "org.xmind.ui.map.unbalanced"
  }
]