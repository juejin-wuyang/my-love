[
  {
    "title": "画布 1",
    "topic": {
      "title": "架构整洁之道",
      "topics": [
        {
          "title": "概述",
          "topics": [
            {
              "title": "完成现在的功能和 未来的灵活度 哪个更加重要,哪个更加紧急呢?"
            },
            {
              "title": "如果忽视软件架构的价值,系统将会变得越来越难以维护, 终会有一天, 系统将会变得再也无法修改. "
            }
          ]
        },
        {
          "title": "编程范式",
          "topics": [
            {
              "title": "结构化编程",
              "topics": [
                {
                  "title": "对程序控制权的直接转义进行了限制和规范.在if, while, 顺序语句之前 ,还存在goto等破坏程序结构的语句."
                },
                {
                  "title": "结构化编程 将程序分割一个个独立的部分,分别加以验证.并且推理证明了,只要程序的各个组成部分是正确的,那么整体就是正确的."
                },
                {
                  "title": "迪杰斯特拉证明了",
                  "topics": [
                    {
                      "title": "程序员可以用将一些证明可用的结构串联起来, 只要自行证明这些额外代码是正确的, 就可以推导出整个程序的正确性"
                    },
                    {
                      "title": "goto语句的某些用法会导致某个模块无法被递归拆分成更小的,可证明的单元,这回导致无法采用分解法将大型问题进一步分成更小的, 可证明的部分."
                    },
                    {
                      "title": "结构化编程可以将模块降解拆分为可推导的单元, 这就意味着模块也可以按照功能进行拆分.这样 讲一个大型问题拆分为一系列高级函数的组合, 而这些高级函数各自又可以继续被拆分为一系列低级函数."
                    }
                  ]
                }
              ]
            },
            {
              "title": "面向对象编程",
              "topics": [
                {
                  "title": "通过对数据和函数进行封装,提供继承和多态,对函数和数据的组织方式进行限制."
                },
                {
                  "title": "继承多态封装并不是面向对象的发明.C 语言同样可以做到继承多态封装."
                },
                {
                  "title": "C 语言 通过 头文件实现封装, 通过强制转换 实现继承, 通过 函数指针实现多态"
                },
                {
                  "title": "依赖反转",
                  "topics": [
                    {
                      "title": "通过设计接口实现 控制流的依赖反转, 例如 A 调用B 实现某个功能, 此时 A 依赖于 B .但是 A 可以抽象出单独的协议或者接口, 让具体的实现 依赖于接口. 此时 A 和接口耦合在一起, 和具体的实现解耦, 此时 变成了 具体实现 反转依赖于  接口.."
                    },
                    {
                      "title": "控制流上调用者和被调者的依赖关系是不变的, 但是在源代码实现级别, 可以修改这种依赖关系."
                    },
                    {
                      "title": "例如微信提供的接口中, 当微信需要调用第三方服务时, 这个接口形式是微信提供的, 微信调用第三方, 是正向依赖, 是控制流的依赖. 但是接口实现上, 是第三方需要遵循微信的标准和协议. 依赖实际上是被反转了"
                    }
                  ]
                },
                {
                  "title": "当某个组件的源代码需要修改时,仅仅需要重新部署该组件, 不需要更改其他组件, 这就是独立部署能力"
                },
                {
                  "title": "如果系统中的所有组件都可以独立部署, 那他们就可以由不同的团队并行开发, 这就是所谓的独立开发能力"
                }
              ]
            },
            {
              "title": "函数式编程",
              "topics": [
                {
                  "title": "lambda表达式意图消除赋值语句. "
                },
                {
                  "title": "lambda表达式 消除了赋值语句,通过一系列函数对输入流进行 有组织的处理, 得到了输出."
                },
                {
                  "title": "lambda通过将变量的修改全部放在了独立的函数里, 在函数间不存在变量修改和赋值.实现了 可变性和不可变性的分离. "
                },
                {
                  "title": "通过将应用程序 中可变部分, 和不可变部分进行分离. 不可变部分用纯函数执行任务, 期间不修改任何状态, 对于可变组件会使用某个事务保护机制修改变量.避免同步竞争和竞争状态破坏数据的一致性."
                }
              ]
            },
            {
              "title": "科学,数学, 和计算机学",
              "topics": [
                {
                  "title": "测试只能展示bug的存在, 但是不能证明不存在bug , 测试只能用来证明其实错误的,不能证明是正确的,只能用来证明程序能足够实现 当前的目标"
                },
                {
                  "title": "科学是证伪.编程也是如此. 就像当年的 引力公式, 只能用来现实现象和观察的数据来证伪 , 一旦无法证伪,甚至证明了某些现象, 其就是在当前的环境是正确的. 但是无法证明其绝对正确. 相对论的发现或者一些诡异的现象无法用相对论解释时, 那么正确性就变成了相对正确性.  同样相对论也是如此,也有可能被推翻的一天. 科学就是不断的在证伪!!!"
                },
                {
                  "title": "数学是要将可证明的结论证明, 科学研究则是将可证明的结论证伪",
                  "topics": [
                    {
                      "title": "数学是在将可证明的结论证明其 是正确的!!!"
                    }
                  ]
                }
              ]
            },
            {
              "title": "最自由的编程方式是使用自己焊的cpu, 自己的指令集, 用数字码进行编程 实现自己产品文档的内容. 毫无疑问, 第一代骨灰级程序员无门五派,无招无式,是最自由的, 同时他们做起事来又常常感觉力不从心."
            }
          ]
        }
      ]
    },
    "structure": "org.xmind.ui.map.unbalanced"
  }
]